{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;;;AAAA,mBAAmB,MAAkC;AACrD,cAAc,6BAA6B,0BAA0B,cAAc,qBAAqB;AACxG,iBAAiB,oDAAoD,qEAAqE,cAAc;AACxJ,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,mCAAmC,SAAS;AAC5C,mCAAmC,WAAW,UAAU;AACxD,0CAA0C,cAAc;AACxD;AACA,8GAA8G,OAAO;AACrH,iFAAiF,iBAAiB;AAClG,yDAAyD,gBAAgB,QAAQ;AACjF,+CAA+C,gBAAgB,gBAAgB;AAC/E;AACA,kCAAkC;AAClC;AACA;AACA,UAAU,YAAY,aAAa,SAAS,UAAU;AACtD,oCAAoC,SAAS;AAC7C;AACA;AACA,cAAc,MAA6B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,qBAAqB,MAAoC;AACzD,6EAA6E,OAAO;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB,gBAAgB,KAAK;AACrB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB,gBAAgB,KAAK;AACrB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB,gBAAgB,KAAK;AACrB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B,gBAAgB,UAAU;AAC1B,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B,gBAAgB,UAAU;AAC1B,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B,gBAAgB,UAAU;AAC1B,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B,gBAAgB,UAAU;AAC1B,gBAAgB,UAAU;AAC1B,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B,gBAAgB,UAAU;AAC1B,gBAAgB,UAAU;AAC1B,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B,gBAAgB,UAAU;AAC1B,gBAAgB,UAAU;AAC1B,gBAAgB,mBAAmB;AACnC;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B,gBAAgB,UAAU;AAC1B,gBAAgB,UAAU;AAC1B,gBAAgB,mBAAmB;AACnC;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B,gBAAgB,UAAU;AAC1B,gBAAgB,UAAU;AAC1B,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B,gBAAgB,UAAU;AAC1B,gBAAgB,UAAU;AAC1B,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,WAAW;AAC3B;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA,sDAAsD,qDAAqD,mCAAmC,IAAI;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B,gBAAgB,UAAU;AAC1B,gBAAgB;AAChB;AACA;AACA,6BAA6B;AAC7B,wDAAwD,mBAAmB;AAC3E;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,UAAU;AAC1B,gBAAgB,cAAc;AAC9B;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,mBAAmB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,UAAU;AAC1B;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA,gCAAgC,4BAA4B;AAC5D,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC,kHAAkH,8BAA8B;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEuC;;;;;;;;;;;;;;;;;;ACx4Bd;AACkC;AAC5B;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wDAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,6CAAI;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,kCAAkC,gDAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;ACzEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZ4B;AACO;AACF;AACoB;AAChB;AACM;AACF;AACF;AACd;AACgB;AACR;AACjB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0DAAU;AACxC,6BAA6B,mDAAS;AACtC;AACA;AACA;AACA;AACA;AACA,mCAAmC,gEAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qEAAqB;AACtC;AACA;AACA,iBAAiB,uEAAuB;AACxC;AACA;AACA,iBAAiB,sEAAsB;AACvC;AACA;AACA,iBAAiB,oEAAoB;AACrC;AACA;AACA,iBAAiB,wEAAwB;AACzC;AACA;AACA,iBAAiB,mEAAmB;AACpC;AACA;AACA,iBAAiB,6EAA6B;AAC9C;AACA;AACA,iBAAiB,oEAAmB;AACpC;AACA;AACA,iBAAiB,uEAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kEAAkB;AAC/D;AACA,aAAa;AACb;AACA,iCAAiC,+DAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kEAAkB;AAC/D;AACA,aAAa;AACb;AACA,iCAAiC,+DAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,kEAAkB;AACnE;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kEAAyB;AAC9C,UAAU;AACV,qBAAqB,kEAAyB;AAC9C;AACA;AACA,cAAc,iDAAiD,EAAE,sEAA6B;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mFAA0C;AAChF,sCAAsC,mFAA0C;AAChF,qCAAqC,kFAAyC;AAC9E,oCAAoC,iFAAwC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,oEAAoB;AAClE,wCAAwC,iEAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,yCAAyC,kEAAkB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+DAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2EAAkC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2EAAkC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mEAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2EAAkC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8DAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+DAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kEAAyB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kEAAkB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,0CAA0C,mEAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,wEAAwB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wFAA+C;AAC1F;AACA;AACA;AACA,qCAAqC,kEAAkB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,wEAAwB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kEAAyB;AAC5D,mCAAmC,kEAAyB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iDAAiD,EAAE,sEAA6B;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,8DAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,mFAA0C;AAChG;AACA;AACA;AACA,sDAAsD,mFAA0C;AAChG,qDAAqD,kFAAyC;AAC9F,oDAAoD,iFAAwC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;;AChe/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wDAAwD;AACtF,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,UAAU,EAAC;;;;;;;;;;;;;;;AC9M1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;;;;;AClFL;AAC4B;AACtB;AAChC;AACA;AACA;AACA;AACA;AACA,6BAA6B,qDAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6CAAI;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,kCAAkC,gDAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,UAAU,EAAC;;;;;;;;;;;;;;;;;AC9D4B;AAC8C;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAa;AACpC;AACA;AACA,yBAAyB,4EAAoC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;ACjCe;AACxC;AACA,8BAA8B,oDAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;;;ACZS;AACxC;AACA,6BAA6B,oDAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,cAAc,EAAC;;;;;;;;;;;;;;;;ACfU;AACxC;AACA,uCAAuC,oDAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,wBAAwB,EAAC;;;;;;;;;;;;;;;ACZxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,WAAW,EAAC;;;;;;;;;;;;;;;;ACPa;AACxC;AACA,+BAA+B,oDAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,gBAAgB,EAAC;;;;;;;;;;;;;;;;ACVQ;AACxC;AACA,kCAAkC,oDAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,mBAAmB,EAAC;;;;;;;;;;;;;;;;ACfK;AACxC;AACA,iCAAiC,oDAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,kBAAkB,EAAC;;;;;;;;;;;;;;;;ACVM;AACxC;AACA,gCAAgC,oDAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,iBAAiB,EAAC;;;;;;;;;;;;;;;;ACVN;AAC3B;AACA;AACA;AACA,2BAA2B,+CAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,UAAU,EAAC;;;;;;;;;;;;;;;;ACtCc;AACxC;AACA,iCAAiC,oDAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,kBAAkB,EAAC;;;;;;;;;;;;;;;;ACVM;AACxC;AACA,6BAA6B,oDAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,cAAc,EAAC;;;;;;;;;;;;;;;;;;ACZE;AACM;AACkC;AACxE;AACA,sBAAsB,mDAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8DAAsB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D,oCAAoC,gDAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;ACrCe;AACtC;AACA,qBAAqB,mDAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;ACvEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;ACzDmE;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAgC;AAC5C;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;AC3HmC;AAC1B;AAChC;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,gDAAO;AACrE;AACA;AACA;AACA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UCzCpB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;;;;WCzBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;;;;;WCJA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WCfA;;WAEA;WACA;WACA;WACA;WACA;WACA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;;;;;;;;;;;;;;;;;;;;;ACrBuD;AACJ;AACF;AACJ;AAC+B;AACN;AACnB;AACA;AACM;AACZ;AACsB;AACnE;AACA;AACA;AACA;AACA,gCAAgC,yGAA4B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kEAAM;AACvB;AACA;AACA;AACA;AACA;AACA,gDAAgD,qEAAS;AACzD,gDAAgD,qEAAS;AACzD,gDAAgD,qEAAS;AACzD,gDAAgD,qEAAS;AACzD,iDAAiD,qEAAS;AAC1D,qDAAqD,qEAAS;AAC9D;AACA,iDAAiD,qEAAS;AAC1D;AACA;AACA;AACA;AACA,kBAAkB,mEAAO;AACzB;AACA;AACA;AACA,eAAe,gEAAI,CAAC,uHAA+D;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mEAAO;AAC1B,mBAAmB,mEAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mEAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAI;AACnB;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mEAAO;AAC1B,mBAAmB,mEAAO;AAC1B,mBAAmB,mEAAO;AAC1B;AACA,mBAAmB,mEAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sEAAU;AAChC,sBAAsB,sEAAU;AAChC,sBAAsB,sEAAU;AAChC,sBAAsB,sEAAU;AAChC,sBAAsB,sEAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4EAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://mwicombatsimulator/./node_modules/heap-js/dist/heap-js.es5.js","webpack://mwicombatsimulator/./src/combatsimulator/ability.js","webpack://mwicombatsimulator/./src/combatsimulator/buff.js","webpack://mwicombatsimulator/./src/combatsimulator/combatSimulator.js","webpack://mwicombatsimulator/./src/combatsimulator/combatUnit.js","webpack://mwicombatsimulator/./src/combatsimulator/combatUtilities.js","webpack://mwicombatsimulator/./src/combatsimulator/consumable.js","webpack://mwicombatsimulator/./src/combatsimulator/equipment.js","webpack://mwicombatsimulator/./src/combatsimulator/events/autoAttackEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/bleedTickEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/checkBuffExpirationEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/combatEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/combatStartEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/consumableTickEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/cooldownReadyEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/enemyRespawnEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/eventQueue.js","webpack://mwicombatsimulator/./src/combatsimulator/events/playerRespawnEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/events/regenTickEvent.js","webpack://mwicombatsimulator/./src/combatsimulator/monster.js","webpack://mwicombatsimulator/./src/combatsimulator/player.js","webpack://mwicombatsimulator/./src/combatsimulator/simResult.js","webpack://mwicombatsimulator/./src/combatsimulator/trigger.js","webpack://mwicombatsimulator/./src/combatsimulator/zone.js","webpack://mwicombatsimulator/webpack/bootstrap","webpack://mwicombatsimulator/webpack/runtime/define property getters","webpack://mwicombatsimulator/webpack/runtime/get javascript chunk filename","webpack://mwicombatsimulator/webpack/runtime/global","webpack://mwicombatsimulator/webpack/runtime/hasOwnProperty shorthand","webpack://mwicombatsimulator/webpack/runtime/make namespace object","webpack://mwicombatsimulator/webpack/runtime/publicPath","webpack://mwicombatsimulator/webpack/runtime/jsonp chunk loading","webpack://mwicombatsimulator/./src/main.js"],"sourcesContent":["var __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar toInt = function (n) { return ~~n; };\n/**\n * Heap\n * @type {Class}\n */\nvar Heap = /** @class */ (function () {\n    /**\n     * Heap instance constructor.\n     * @param  {Function} compare Optional comparison function, defaults to Heap.minComparator<number>\n     */\n    function Heap(compare) {\n        if (compare === void 0) { compare = Heap.minComparator; }\n        var _this = this;\n        this.compare = compare;\n        this.heapArray = [];\n        this._limit = 0;\n        /**\n         * Alias of add\n         */\n        this.offer = this.add;\n        /**\n         * Alias of peek\n         */\n        this.element = this.peek;\n        /**\n         * Alias of pop\n         */\n        this.poll = this.pop;\n        /**\n         * Returns the inverse to the comparison function.\n         * @return {Function}\n         */\n        this._invertedCompare = function (a, b) {\n            return -1 * _this.compare(a, b);\n        };\n    }\n    /*\n              Static methods\n     */\n    /**\n     * Gets children indices for given index.\n     * @param  {Number} idx     Parent index\n     * @return {Array(Number)}  Array of children indices\n     */\n    Heap.getChildrenIndexOf = function (idx) {\n        return [idx * 2 + 1, idx * 2 + 2];\n    };\n    /**\n     * Gets parent index for given index.\n     * @param  {Number} idx  Children index\n     * @return {Number | undefined}      Parent index, -1 if idx is 0\n     */\n    Heap.getParentIndexOf = function (idx) {\n        if (idx <= 0) {\n            return -1;\n        }\n        var whichChildren = idx % 2 ? 1 : 2;\n        return Math.floor((idx - whichChildren) / 2);\n    };\n    /**\n     * Gets sibling index for given index.\n     * @param  {Number} idx  Children index\n     * @return {Number | undefined}      Sibling index, -1 if idx is 0\n     */\n    Heap.getSiblingIndexOf = function (idx) {\n        if (idx <= 0) {\n            return -1;\n        }\n        var whichChildren = idx % 2 ? 1 : -1;\n        return idx + whichChildren;\n    };\n    /**\n     * Min heap comparison function, default.\n     * @param  {any} a     First element\n     * @param  {any} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    Heap.minComparator = function (a, b) {\n        if (a > b) {\n            return 1;\n        }\n        else if (a < b) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    };\n    /**\n     * Max heap comparison function.\n     * @param  {any} a     First element\n     * @param  {any} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    Heap.maxComparator = function (a, b) {\n        if (b > a) {\n            return 1;\n        }\n        else if (b < a) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    };\n    /**\n     * Min number heap comparison function, default.\n     * @param  {Number} a     First element\n     * @param  {Number} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    Heap.minComparatorNumber = function (a, b) {\n        return a - b;\n    };\n    /**\n     * Max number heap comparison function.\n     * @param  {Number} a     First element\n     * @param  {Number} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    Heap.maxComparatorNumber = function (a, b) {\n        return b - a;\n    };\n    /**\n     * Default equality function.\n     * @param  {any} a    First element\n     * @param  {any} b    Second element\n     * @return {Boolean}  True if equal, false otherwise\n     */\n    Heap.defaultIsEqual = function (a, b) {\n        return a === b;\n    };\n    /**\n     * Prints a heap.\n     * @param  {Heap} heap Heap to be printed\n     * @returns {String}\n     */\n    Heap.print = function (heap) {\n        function deep(i) {\n            var pi = Heap.getParentIndexOf(i);\n            return Math.floor(Math.log2(pi + 1));\n        }\n        function repeat(str, times) {\n            var out = '';\n            for (; times > 0; --times) {\n                out += str;\n            }\n            return out;\n        }\n        var node = 0;\n        var lines = [];\n        var maxLines = deep(heap.length - 1) + 2;\n        var maxLength = 0;\n        while (node < heap.length) {\n            var i = deep(node) + 1;\n            if (node === 0) {\n                i = 0;\n            }\n            // Text representation\n            var nodeText = String(heap.get(node));\n            if (nodeText.length > maxLength) {\n                maxLength = nodeText.length;\n            }\n            // Add to line\n            lines[i] = lines[i] || [];\n            lines[i].push(nodeText);\n            node += 1;\n        }\n        return lines\n            .map(function (line, i) {\n            var times = Math.pow(2, maxLines - i) - 1;\n            return (repeat(' ', Math.floor(times / 2) * maxLength) +\n                line\n                    .map(function (el) {\n                    // centered\n                    var half = (maxLength - el.length) / 2;\n                    return repeat(' ', Math.ceil(half)) + el + repeat(' ', Math.floor(half));\n                })\n                    .join(repeat(' ', times * maxLength)));\n        })\n            .join('\\n');\n    };\n    /*\n              Python style\n     */\n    /**\n     * Converts an array into an array-heap, in place\n     * @param  {Array}    arr      Array to be modified\n     * @param  {Function} compare  Optional compare function\n     * @return {Heap}              For convenience, it returns a Heap instance\n     */\n    Heap.heapify = function (arr, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = arr;\n        heap.init();\n        return heap;\n    };\n    /**\n     * Extract the peek of an array-heap\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Returns the extracted peek\n     */\n    Heap.heappop = function (heapArr, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.pop();\n    };\n    /**\n     * Pushes a item into an array-heap\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {any}      item     Item to push\n     * @param  {Function} compare  Optional compare function\n     */\n    Heap.heappush = function (heapArr, item, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        heap.push(item);\n    };\n    /**\n     * Push followed by pop, faster\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {any}      item     Item to push\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Returns the extracted peek\n     */\n    Heap.heappushpop = function (heapArr, item, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.pushpop(item);\n    };\n    /**\n     * Replace peek with item\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {any}      item     Item as replacement\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Returns the extracted peek\n     */\n    Heap.heapreplace = function (heapArr, item, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.replace(item);\n    };\n    /**\n     * Return the `n` most valuable elements of a heap-like Array\n     * @param  {Array}    heapArr  Array, should be an array-heap\n     * @param  {number}   n        Max number of elements\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Elements\n     */\n    Heap.heaptop = function (heapArr, n, compare) {\n        if (n === void 0) { n = 1; }\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.top(n);\n    };\n    /**\n     * Return the `n` least valuable elements of a heap-like Array\n     * @param  {Array}    heapArr  Array, should be an array-heap\n     * @param  {number}   n        Max number of elements\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Elements\n     */\n    Heap.heapbottom = function (heapArr, n, compare) {\n        if (n === void 0) { n = 1; }\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.bottom(n);\n    };\n    /**\n     * Return the `n` most valuable elements of an iterable\n     * @param  {number}   n        Max number of elements\n     * @param  {Iterable} Iterable Iterable list of elements\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Elements\n     */\n    Heap.nlargest = function (n, iterable, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = __spreadArray([], __read(iterable), false);\n        heap.init();\n        return heap.top(n);\n    };\n    /**\n     * Return the `n` least valuable elements of an iterable\n     * @param  {number}   n        Max number of elements\n     * @param  {Iterable} Iterable Iterable list of elements\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Elements\n     */\n    Heap.nsmallest = function (n, iterable, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = __spreadArray([], __read(iterable), false);\n        heap.init();\n        return heap.bottom(n);\n    };\n    /*\n              Instance methods\n     */\n    /**\n     * Adds an element to the heap. Aliases: `offer`.\n     * Same as: push(element)\n     * @param {any} element Element to be added\n     * @return {Boolean} true\n     */\n    Heap.prototype.add = function (element) {\n        this._sortNodeUp(this.heapArray.push(element) - 1);\n        this._applyLimit();\n        return true;\n    };\n    /**\n     * Adds an array of elements to the heap.\n     * Similar as: push(element, element, ...).\n     * @param {Array} elements Elements to be added\n     * @return {Boolean} true\n     */\n    Heap.prototype.addAll = function (elements) {\n        var _a;\n        var i = this.length;\n        (_a = this.heapArray).push.apply(_a, __spreadArray([], __read(elements), false));\n        for (var l = this.length; i < l; ++i) {\n            this._sortNodeUp(i);\n        }\n        this._applyLimit();\n        return true;\n    };\n    /**\n     * Return the bottom (lowest value) N elements of the heap.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype.bottom = function (n) {\n        if (n === void 0) { n = 1; }\n        if (this.heapArray.length === 0 || n <= 0) {\n            // Nothing to do\n            return [];\n        }\n        else if (this.heapArray.length === 1) {\n            // Just the peek\n            return [this.heapArray[0]];\n        }\n        else if (n >= this.heapArray.length) {\n            // The whole heap\n            return __spreadArray([], __read(this.heapArray), false);\n        }\n        else {\n            // Some elements\n            var result = this._bottomN_push(~~n);\n            return result;\n        }\n    };\n    /**\n     * Check if the heap is sorted, useful for testing purposes.\n     * @return {Undefined | Element}  Returns an element if something wrong is found, otherwise it's undefined\n     */\n    Heap.prototype.check = function () {\n        var _this = this;\n        return this.heapArray.find(function (el, j) { return !!_this.getChildrenOf(j).find(function (ch) { return _this.compare(el, ch) > 0; }); });\n    };\n    /**\n     * Remove all of the elements from this heap.\n     */\n    Heap.prototype.clear = function () {\n        this.heapArray = [];\n    };\n    /**\n     * Clone this heap\n     * @return {Heap}\n     */\n    Heap.prototype.clone = function () {\n        var cloned = new Heap(this.comparator());\n        cloned.heapArray = this.toArray();\n        cloned._limit = this._limit;\n        return cloned;\n    };\n    /**\n     * Returns the comparison function.\n     * @return {Function}\n     */\n    Heap.prototype.comparator = function () {\n        return this.compare;\n    };\n    /**\n     * Returns true if this queue contains the specified element.\n     * @param  {any}      o   Element to be found\n     * @param  {Function} fn  Optional comparison function, receives (element, needle)\n     * @return {Boolean}\n     */\n    Heap.prototype.contains = function (o, fn) {\n        if (fn === void 0) { fn = Heap.defaultIsEqual; }\n        return this.heapArray.findIndex(function (el) { return fn(el, o); }) >= 0;\n    };\n    /**\n     * Initialise a heap, sorting nodes\n     * @param  {Array} array Optional initial state array\n     */\n    Heap.prototype.init = function (array) {\n        if (array) {\n            this.heapArray = __spreadArray([], __read(array), false);\n        }\n        for (var i = Math.floor(this.heapArray.length); i >= 0; --i) {\n            this._sortNodeDown(i);\n        }\n        this._applyLimit();\n    };\n    /**\n     * Test if the heap has no elements.\n     * @return {Boolean} True if no elements on the heap\n     */\n    Heap.prototype.isEmpty = function () {\n        return this.length === 0;\n    };\n    /**\n     * Get the leafs of the tree (no children nodes)\n     */\n    Heap.prototype.leafs = function () {\n        if (this.heapArray.length === 0) {\n            return [];\n        }\n        var pi = Heap.getParentIndexOf(this.heapArray.length - 1);\n        return this.heapArray.slice(pi + 1);\n    };\n    Object.defineProperty(Heap.prototype, \"length\", {\n        /**\n         * Length of the heap.\n         * @return {Number}\n         */\n        get: function () {\n            return this.heapArray.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Heap.prototype, \"limit\", {\n        /**\n         * Get length limit of the heap.\n         * @return {Number}\n         */\n        get: function () {\n            return this._limit;\n        },\n        /**\n         * Set length limit of the heap.\n         * @return {Number}\n         */\n        set: function (_l) {\n            this._limit = ~~_l;\n            this._applyLimit();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Top node. Aliases: `element`.\n     * Same as: `top(1)[0]`\n     * @return {any} Top node\n     */\n    Heap.prototype.peek = function () {\n        return this.heapArray[0];\n    };\n    /**\n     * Extract the top node (root). Aliases: `poll`.\n     * @return {any} Extracted top node, undefined if empty\n     */\n    Heap.prototype.pop = function () {\n        var last = this.heapArray.pop();\n        if (this.length > 0 && last !== undefined) {\n            return this.replace(last);\n        }\n        return last;\n    };\n    /**\n     * Pushes element(s) to the heap.\n     * @param  {...any} elements Elements to insert\n     * @return {Boolean} True if elements are present\n     */\n    Heap.prototype.push = function () {\n        var elements = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            elements[_i] = arguments[_i];\n        }\n        if (elements.length < 1) {\n            return false;\n        }\n        else if (elements.length === 1) {\n            return this.add(elements[0]);\n        }\n        else {\n            return this.addAll(elements);\n        }\n    };\n    /**\n     * Same as push & pop in sequence, but faster\n     * @param  {any} element Element to insert\n     * @return {any}  Extracted top node\n     */\n    Heap.prototype.pushpop = function (element) {\n        var _a;\n        if (this.compare(this.heapArray[0], element) < 0) {\n            _a = __read([this.heapArray[0], element], 2), element = _a[0], this.heapArray[0] = _a[1];\n            this._sortNodeDown(0);\n        }\n        return element;\n    };\n    /**\n     * Remove an element from the heap.\n     * @param  {any}   o      Element to be found\n     * @param  {Function} fn  Optional function to compare\n     * @return {Boolean}      True if the heap was modified\n     */\n    Heap.prototype.remove = function (o, fn) {\n        if (fn === void 0) { fn = Heap.defaultIsEqual; }\n        if (this.length > 0) {\n            if (o === undefined) {\n                this.pop();\n                return true;\n            }\n            else {\n                var idx = this.heapArray.findIndex(function (el) { return fn(el, o); });\n                if (idx >= 0) {\n                    if (idx === 0) {\n                        this.pop();\n                    }\n                    else if (idx === this.length - 1) {\n                        this.heapArray.pop();\n                    }\n                    else {\n                        this.heapArray.splice(idx, 1, this.heapArray.pop());\n                        this._sortNodeUp(idx);\n                        this._sortNodeDown(idx);\n                    }\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    /**\n     * Pop the current peek value, and add the new item.\n     * @param  {any} element  Element to replace peek\n     * @return {any}         Old peek\n     */\n    Heap.prototype.replace = function (element) {\n        var peek = this.heapArray[0];\n        this.heapArray[0] = element;\n        this._sortNodeDown(0);\n        return peek;\n    };\n    /**\n     * Size of the heap\n     * @return {Number}\n     */\n    Heap.prototype.size = function () {\n        return this.length;\n    };\n    /**\n     * Return the top (highest value) N elements of the heap.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}    Array of length <= N.\n     */\n    Heap.prototype.top = function (n) {\n        if (n === void 0) { n = 1; }\n        if (this.heapArray.length === 0 || n <= 0) {\n            // Nothing to do\n            return [];\n        }\n        else if (this.heapArray.length === 1 || n === 1) {\n            // Just the peek\n            return [this.heapArray[0]];\n        }\n        else if (n >= this.heapArray.length) {\n            // The whole peek\n            return __spreadArray([], __read(this.heapArray), false);\n        }\n        else {\n            // Some elements\n            var result = this._topN_push(~~n);\n            return result;\n        }\n    };\n    /**\n     * Clone the heap's internal array\n     * @return {Array}\n     */\n    Heap.prototype.toArray = function () {\n        return __spreadArray([], __read(this.heapArray), false);\n    };\n    /**\n     * String output, call to Array.prototype.toString()\n     * @return {String}\n     */\n    Heap.prototype.toString = function () {\n        return this.heapArray.toString();\n    };\n    /**\n     * Get the element at the given index.\n     * @param  {Number} i Index to get\n     * @return {any}       Element at that index\n     */\n    Heap.prototype.get = function (i) {\n        return this.heapArray[i];\n    };\n    /**\n     * Get the elements of these node's children\n     * @param  {Number} idx Node index\n     * @return {Array(any)}  Children elements\n     */\n    Heap.prototype.getChildrenOf = function (idx) {\n        var _this = this;\n        return Heap.getChildrenIndexOf(idx)\n            .map(function (i) { return _this.heapArray[i]; })\n            .filter(function (e) { return e !== undefined; });\n    };\n    /**\n     * Get the element of this node's parent\n     * @param  {Number} idx Node index\n     * @return {any}     Parent element\n     */\n    Heap.prototype.getParentOf = function (idx) {\n        var pi = Heap.getParentIndexOf(idx);\n        return this.heapArray[pi];\n    };\n    /**\n     * Iterator interface\n     */\n    Heap.prototype[Symbol.iterator] = function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!this.length) return [3 /*break*/, 2];\n                    return [4 /*yield*/, this.pop()];\n                case 1:\n                    _a.sent();\n                    return [3 /*break*/, 0];\n                case 2: return [2 /*return*/];\n            }\n        });\n    };\n    /**\n     * Returns an iterator. To comply with Java interface.\n     */\n    Heap.prototype.iterator = function () {\n        return this.toArray();\n    };\n    /**\n     * Limit heap size if needed\n     */\n    Heap.prototype._applyLimit = function () {\n        if (this._limit && this._limit < this.heapArray.length) {\n            var rm = this.heapArray.length - this._limit;\n            // It's much faster than splice\n            while (rm) {\n                this.heapArray.pop();\n                --rm;\n            }\n        }\n    };\n    /**\n     * Return the bottom (lowest value) N elements of the heap, without corner cases, unsorted\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype._bottomN_push = function (n) {\n        // Use an inverted heap\n        var bottomHeap = new Heap(this.compare);\n        bottomHeap.limit = n;\n        bottomHeap.heapArray = this.heapArray.slice(-n);\n        bottomHeap.init();\n        var startAt = this.heapArray.length - 1 - n;\n        var parentStartAt = Heap.getParentIndexOf(startAt);\n        var indices = [];\n        for (var i = startAt; i > parentStartAt; --i) {\n            indices.push(i);\n        }\n        var arr = this.heapArray;\n        while (indices.length) {\n            var i = indices.shift();\n            if (this.compare(arr[i], bottomHeap.peek()) > 0) {\n                bottomHeap.replace(arr[i]);\n                if (i % 2) {\n                    indices.push(Heap.getParentIndexOf(i));\n                }\n            }\n        }\n        return bottomHeap.toArray();\n    };\n    /**\n     * Move a node to a new index, switching places\n     * @param  {Number} j First node index\n     * @param  {Number} k Another node index\n     */\n    Heap.prototype._moveNode = function (j, k) {\n        var _a;\n        _a = __read([this.heapArray[k], this.heapArray[j]], 2), this.heapArray[j] = _a[0], this.heapArray[k] = _a[1];\n    };\n    /**\n     * Move a node down the tree (to the leaves) to find a place where the heap is sorted.\n     * @param  {Number} i Index of the node\n     */\n    Heap.prototype._sortNodeDown = function (i) {\n        var _this = this;\n        var moveIt = i < this.heapArray.length - 1;\n        var self = this.heapArray[i];\n        var getPotentialParent = function (best, j) {\n            if (_this.heapArray.length > j && _this.compare(_this.heapArray[j], _this.heapArray[best]) < 0) {\n                best = j;\n            }\n            return best;\n        };\n        while (moveIt) {\n            var childrenIdx = Heap.getChildrenIndexOf(i);\n            var bestChildIndex = childrenIdx.reduce(getPotentialParent, childrenIdx[0]);\n            var bestChild = this.heapArray[bestChildIndex];\n            if (typeof bestChild !== 'undefined' && this.compare(self, bestChild) > 0) {\n                this._moveNode(i, bestChildIndex);\n                i = bestChildIndex;\n            }\n            else {\n                moveIt = false;\n            }\n        }\n    };\n    /**\n     * Move a node up the tree (to the root) to find a place where the heap is sorted.\n     * @param  {Number} i Index of the node\n     */\n    Heap.prototype._sortNodeUp = function (i) {\n        var moveIt = i > 0;\n        while (moveIt) {\n            var pi = Heap.getParentIndexOf(i);\n            if (pi >= 0 && this.compare(this.heapArray[pi], this.heapArray[i]) > 0) {\n                this._moveNode(i, pi);\n                i = pi;\n            }\n            else {\n                moveIt = false;\n            }\n        }\n    };\n    /**\n     * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n     * Implementation: push.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype._topN_push = function (n) {\n        // Use an inverted heap\n        var topHeap = new Heap(this._invertedCompare);\n        topHeap.limit = n;\n        var indices = [0];\n        var arr = this.heapArray;\n        while (indices.length) {\n            var i = indices.shift();\n            if (i < arr.length) {\n                if (topHeap.length < n) {\n                    topHeap.push(arr[i]);\n                    indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i)), false));\n                }\n                else if (this.compare(arr[i], topHeap.peek()) < 0) {\n                    topHeap.replace(arr[i]);\n                    indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i)), false));\n                }\n            }\n        }\n        return topHeap.toArray();\n    };\n    /**\n     * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n     * Implementation: init + push.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype._topN_fill = function (n) {\n        // Use an inverted heap\n        var heapArray = this.heapArray;\n        var topHeap = new Heap(this._invertedCompare);\n        topHeap.limit = n;\n        topHeap.heapArray = heapArray.slice(0, n);\n        topHeap.init();\n        var branch = Heap.getParentIndexOf(n - 1) + 1;\n        var indices = [];\n        for (var i = branch; i < n; ++i) {\n            indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i).filter(function (l) { return l < heapArray.length; })), false));\n        }\n        if ((n - 1) % 2) {\n            indices.push(n);\n        }\n        while (indices.length) {\n            var i = indices.shift();\n            if (i < heapArray.length) {\n                if (this.compare(heapArray[i], topHeap.peek()) < 0) {\n                    topHeap.replace(heapArray[i]);\n                    indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i)), false));\n                }\n            }\n        }\n        return topHeap.toArray();\n    };\n    /**\n     * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n     * Implementation: heap.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype._topN_heap = function (n) {\n        var topHeap = this.clone();\n        var result = [];\n        for (var i = 0; i < n; ++i) {\n            result.push(topHeap.pop());\n        }\n        return result;\n    };\n    /**\n     * Return index of the top element\n     * @param list\n     */\n    Heap.prototype._topIdxOf = function (list) {\n        if (!list.length) {\n            return -1;\n        }\n        var idx = 0;\n        var top = list[idx];\n        for (var i = 1; i < list.length; ++i) {\n            var comp = this.compare(list[i], top);\n            if (comp < 0) {\n                idx = i;\n                top = list[i];\n            }\n        }\n        return idx;\n    };\n    /**\n     * Return the top element\n     * @param list\n     */\n    Heap.prototype._topOf = function () {\n        var list = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            list[_i] = arguments[_i];\n        }\n        var heap = new Heap(this.compare);\n        heap.init(list);\n        return heap.peek();\n    };\n    return Heap;\n}());\n\nexport { Heap, Heap as default, toInt };\n","import Buff from \"./buff\";\r\nimport abilityDetailMap from \"./data/abilityDetailMap.json\";\r\nimport Trigger from \"./trigger\";\r\n\r\nclass Ability {\r\n    constructor(hrid, level, triggers = null) {\r\n        this.hrid = hrid;\r\n        this.level = level;\r\n\r\n        let gameAbility = abilityDetailMap[hrid];\r\n        console.assert(gameAbility, \"No ability found for hrid:\" + this.hrid);\r\n\r\n        this.manaCost = gameAbility.manaCost;\r\n        this.cooldownDuration = gameAbility.cooldownDuration;\r\n\r\n        this.abilityEffects = [];\r\n\r\n        for (const effect of gameAbility.abilityEffects) {\r\n            let abilityEffect = {\r\n                targetType: effect.targetType,\r\n                effectType: effect.effectType,\r\n                combatStyleHrid: effect.combatStyleHrid.slice(effect.combatStyleHrid.lastIndexOf(\"/\") + 1),\r\n                damageFlat: effect.baseDamageFlat + (this.level - 1) * effect.baseDamageFlatLevelBonus,\r\n                damageRatio: effect.baseDamageRatio + (this.level - 1) * effect.baseDamageRatioLevelBonus,\r\n                bleedRatio: effect.bleedRatio,\r\n                duration: effect.duration,\r\n                buff: effect.buff.duration > 0 ? new Buff(effect.buff, this.level) : null,\r\n            };\r\n            this.abilityEffects.push(abilityEffect);\r\n        }\r\n\r\n        if (triggers) {\r\n            this.triggers = triggers;\r\n        } else {\r\n            this.triggers = [];\r\n            for (const defaultTrigger of gameAbility.defaultCombatTriggers) {\r\n                let trigger = new Trigger(\r\n                    defaultTrigger.dependencyHrid,\r\n                    defaultTrigger.conditionHrid,\r\n                    defaultTrigger.comparatorHrid,\r\n                    defaultTrigger.value\r\n                );\r\n                this.triggers.push(trigger);\r\n            }\r\n        }\r\n\r\n        this.lastUsed = Number.MIN_SAFE_INTEGER;\r\n    }\r\n\r\n    shouldTrigger(currentTime, source, target, friendlies, enemies) {\r\n        if (this.lastUsed + this.cooldownDuration > currentTime) {\r\n            return false;\r\n        }\r\n\r\n        if (source.combatStats.currentManapoints < this.manaCost) {\r\n            return false;\r\n        }\r\n\r\n        if (this.triggers.length == 0) {\r\n            return true;\r\n        }\r\n\r\n        let shouldTrigger = true;\r\n        for (const trigger of this.triggers) {\r\n            if (!trigger.isActive(source, target, friendlies, enemies)) {\r\n                shouldTrigger = false;\r\n            }\r\n        }\r\n\r\n        return shouldTrigger;\r\n    }\r\n}\r\n\r\nexport default Ability;\r\n","class Buff {\r\n    startTime;\r\n\r\n    constructor(buff, level = 1) {\r\n        this.sourceHrid = buff.sourceHrid;\r\n        this.typeHrid = buff.typeHrid;\r\n        this.ratioBoost = buff.ratioBoost + (level - 1) * buff.ratioBoostLevelBonus;\r\n        this.flatBoost = buff.flatBoost + (level - 1) * buff.flatBoostLevelBonus;\r\n        this.duration = buff.duration;\r\n    }\r\n}\r\n\r\nexport default Buff;\r\n","import CombatUtilities from \"./combatUtilities\";\r\nimport AutoAttackEvent from \"./events/autoAttackEvent\";\r\nimport BleedTickEvent from \"./events/bleedTickEvent\";\r\nimport CheckBuffExpirationEvent from \"./events/checkBuffExpirationEvent\";\r\nimport CombatStartEvent from \"./events/combatStartEvent\";\r\nimport ConsumableTickEvent from \"./events/consumableTickEvent\";\r\nimport CooldownReadyEvent from \"./events/cooldownReadyEvent\";\r\nimport EnemyRespawnEvent from \"./events/enemyRespawnEvent\";\r\nimport EventQueue from \"./events/eventQueue\";\r\nimport PlayerRespawnEvent from \"./events/playerRespawnEvent\";\r\nimport RegenTickEvent from \"./events/regenTickEvent\";\r\nimport SimResult from \"./simResult\";\r\n\r\nclass CombatSimulator {\r\n    constructor(player, zone) {\r\n        this.players = [player];\r\n        this.zone = zone;\r\n\r\n        this.eventQueue = new EventQueue();\r\n        this.simResult = new SimResult();\r\n    }\r\n\r\n    simulate(simulationTimeLimit) {\r\n        this.reset();\r\n\r\n        let combatStartEvent = new CombatStartEvent(0);\r\n        this.eventQueue.addEvent(combatStartEvent);\r\n\r\n        while (this.simulationTime < simulationTimeLimit) {\r\n            let nextEvent = this.eventQueue.getNextEvent();\r\n            this.processEvent(nextEvent);\r\n        }\r\n\r\n        this.simResult.simulatedTime = this.simulationTime;\r\n\r\n        return this.simResult;\r\n    }\r\n\r\n    reset() {\r\n        this.simulationTime = 0;\r\n        this.eventQueue.clear();\r\n        this.simResult = new SimResult();\r\n    }\r\n\r\n    processEvent(event) {\r\n        this.simulationTime = event.time;\r\n\r\n        // console.log(this.simulationTime / 1e9, event.type, event);\r\n\r\n        switch (event.type) {\r\n            case CombatStartEvent.type:\r\n                this.processCombatStartEvent(event);\r\n                break;\r\n            case PlayerRespawnEvent.type:\r\n                this.processPlayerRespawnEvent(event);\r\n                break;\r\n            case EnemyRespawnEvent.type:\r\n                this.processEnemyRespawnEvent(event);\r\n                break;\r\n            case AutoAttackEvent.type:\r\n                this.processAutoAttackEvent(event);\r\n                break;\r\n            case ConsumableTickEvent.type:\r\n                this.processConsumableTickEvent(event);\r\n                break;\r\n            case BleedTickEvent.type:\r\n                this.processBleedTickEvent(event);\r\n                break;\r\n            case CheckBuffExpirationEvent.type:\r\n                this.processCheckBuffExpirationEvent(event);\r\n                break;\r\n            case RegenTickEvent.type:\r\n                this.processRegenTickEvent(event);\r\n                break;\r\n            case CooldownReadyEvent.type:\r\n                // Only used to check triggers\r\n                break;\r\n        }\r\n\r\n        this.checkTriggers();\r\n    }\r\n\r\n    processCombatStartEvent(event) {\r\n        this.players[0].reset(this.simulationTime);\r\n\r\n        this.players[0].abilities\r\n            .filter((ability) => ability != null)\r\n            .forEach((ability) => {\r\n                let cooldownReadyEvent = new CooldownReadyEvent(ability.lastUsed + ability.cooldownDuration);\r\n                this.eventQueue.addEvent(cooldownReadyEvent);\r\n            });\r\n\r\n        let regenTickEvent = new RegenTickEvent(this.simulationTime + 10 * 1e9, this.players[0]);\r\n        this.eventQueue.addEvent(regenTickEvent);\r\n\r\n        this.startNewEncounter();\r\n    }\r\n\r\n    processPlayerRespawnEvent(event) {\r\n        this.players[0].combatStats.currentHitpoints = this.players[0].combatStats.maxHitpoints / 2;\r\n        this.players[0].clearBuffs();\r\n\r\n        this.players[0].resetCooldowns(this.simulationTime);\r\n        this.players[0].abilities\r\n            .filter((ability) => ability != null)\r\n            .forEach((ability) => {\r\n                let cooldownReadyEvent = new CooldownReadyEvent(ability.lastUsed + ability.cooldownDuration);\r\n                this.eventQueue.addEvent(cooldownReadyEvent);\r\n            });\r\n\r\n        let regenTickEvent = new RegenTickEvent(this.simulationTime + 10 * 1e9, this.players[0]);\r\n        this.eventQueue.addEvent(regenTickEvent);\r\n\r\n        this.startNewEncounter();\r\n    }\r\n\r\n    processEnemyRespawnEvent(event) {\r\n        this.startNewEncounter();\r\n    }\r\n\r\n    startNewEncounter() {\r\n        this.enemies = this.zone.getRandomEncounter();\r\n\r\n        this.enemies.forEach((enemy) => {\r\n            enemy.reset(this.simulationTime);\r\n            enemy.abilities\r\n                .filter((ability) => ability != null)\r\n                .forEach((ability) => {\r\n                    let cooldownReadyEvent = new CooldownReadyEvent(ability.lastUsed + ability.cooldownDuration);\r\n                    this.eventQueue.addEvent(cooldownReadyEvent);\r\n                });\r\n            // console.log(enemy.hrid, \"spawned\");\r\n        });\r\n\r\n        this.addNextAutoAttackEvent(this.players[0]);\r\n\r\n        this.enemies.forEach((enemy) => this.addNextAutoAttackEvent(enemy));\r\n    }\r\n\r\n    processAutoAttackEvent(event) {\r\n        // console.log(\"source:\", event.source.hrid, \"target:\", event.target.hrid);\r\n\r\n        let target;\r\n        if (event.source.isPlayer) {\r\n            target = CombatUtilities.getTarget(this.enemies);\r\n        } else {\r\n            target = CombatUtilities.getTarget(this.players);\r\n        }\r\n\r\n        let { damageDone, damagePrevented, maxDamage, didHit } = CombatUtilities.processAttack(\r\n            event.source,\r\n            target\r\n        );\r\n        // console.log(\"Hit for\", damageDone);\r\n\r\n        if (event.source.combatStats.lifeSteal > 0) {\r\n            let lifeStealHeal = Math.floor(damageDone * event.source.combatStats.lifeSteal);\r\n            let hitpointsAdded = event.source.addHitpoints(lifeStealHeal);\r\n            // console.log(\"Added hitpoints from life steal:\", hitpointsAdded);\r\n        }\r\n\r\n        this.simResult.addAttack(event.source, target, \"autoAttack\", didHit ? damageDone : \"miss\");\r\n\r\n        let targetStaminaExperience = CombatUtilities.calculateStaminaExperience(damagePrevented, damageDone);\r\n        let targetDefenseExperience = CombatUtilities.calculateDefenseExperience(damagePrevented);\r\n        let sourceAttackExperience = CombatUtilities.calculateAttackExperience(damageDone);\r\n        let sourcePowerExperience = CombatUtilities.calculatePowerExperience(maxDamage);\r\n\r\n        this.simResult.addExperienceGain(target, \"stamina\", targetStaminaExperience);\r\n        this.simResult.addExperienceGain(target, \"defense\", targetDefenseExperience);\r\n        this.simResult.addExperienceGain(event.source, \"attack\", sourceAttackExperience);\r\n        this.simResult.addExperienceGain(event.source, \"power\", sourcePowerExperience);\r\n\r\n        if (target.combatStats.currentHitpoints == 0) {\r\n            this.eventQueue.clearEventsForUnit(target);\r\n            this.simResult.addDeath(target);\r\n            // console.log(event.target.hrid, \"died\");\r\n        }\r\n\r\n        if (!this.checkEncounterEnd()) {\r\n            this.addNextAutoAttackEvent(event.source);\r\n        }\r\n    }\r\n\r\n    checkEncounterEnd() {\r\n        if (this.enemies && !this.enemies.find((enemy) => enemy.combatStats.currentHitpoints > 0)) {\r\n            this.eventQueue.clearEventsOfType(AutoAttackEvent.type);\r\n            let enemyRespawnEvent = new EnemyRespawnEvent(this.simulationTime + 3 * 1e9);\r\n            this.eventQueue.addEvent(enemyRespawnEvent);\r\n            this.enemies = null;\r\n\r\n            this.simResult.addEncounterEnd();\r\n            // console.log(\"All enemies died\");\r\n\r\n            return true;\r\n        } else if (!this.players.find((player) => player.combatStats.currentHitpoints > 0)) {\r\n            this.eventQueue.clear();\r\n            // 120 seconds respawn and 30 seconds traveling to battle\r\n            let playerRespawnEvent = new PlayerRespawnEvent(this.simulationTime + 150 * 1e9);\r\n            this.eventQueue.addEvent(playerRespawnEvent);\r\n            this.enemies = null;\r\n\r\n            this.simResult.addEncounterEnd();\r\n            // console.log(\"Player died\");\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    addNextAutoAttackEvent(source) {\r\n        let autoAttackEvent = new AutoAttackEvent(\r\n            this.simulationTime + source.combatStats.attackInterval,\r\n            source\r\n        );\r\n        this.eventQueue.addEvent(autoAttackEvent);\r\n    }\r\n\r\n    processConsumableTickEvent(event) {\r\n        if (event.consumable.hitpointRestore > 0) {\r\n            let tickValue = CombatUtilities.calculateTickValue(\r\n                event.consumable.hitpointRestore,\r\n                event.totalTicks,\r\n                event.currentTick\r\n            );\r\n            let hitpointsAdded = event.source.addHitpoints(tickValue);\r\n            // console.log(\"Added hitpoints:\", hitpointsAdded);\r\n        }\r\n\r\n        if (event.consumable.manapointRestore > 0) {\r\n            let tickValue = CombatUtilities.calculateTickValue(\r\n                event.consumable.manapointRestore,\r\n                event.totalTicks,\r\n                event.currentTick\r\n            );\r\n            let manapointsAdded = event.source.addManapoints(tickValue);\r\n            // console.log(\"Added manapoints:\", manapointsAdded);\r\n        }\r\n\r\n        if (event.currentTick < event.totalTicks) {\r\n            let consumableTickEvent = new ConsumableTickEvent(\r\n                this.simulationTime + 2 * 1e9,\r\n                event.source,\r\n                event.consumable,\r\n                event.totalTicks,\r\n                event.currentTick + 1\r\n            );\r\n            this.eventQueue.addEvent(consumableTickEvent);\r\n        }\r\n    }\r\n\r\n    processBleedTickEvent(event) {\r\n        let tickDamage = CombatUtilities.calculateTickValue(event.damage, event.totalTicks, event.currentTick);\r\n        let damage = Math.min(tickDamage, event.target.combatStats.currentHitpoints);\r\n\r\n        event.target.combatStats.currentHitpoints -= damage;\r\n        // console.log(event.target.hrid, \"bleed for\", damage);\r\n\r\n        if (event.currentTick < event.totalTicks) {\r\n            let bleedTickEvent = new BleedTickEvent(\r\n                this.simulationTime + 2 * 1e9,\r\n                event.target,\r\n                event.damage,\r\n                event.totalTicks,\r\n                event.currentTick + 1\r\n            );\r\n            this.eventQueue.addEvent(bleedTickEvent);\r\n        }\r\n\r\n        if (event.target.combatStats.currentHitpoints == 0) {\r\n            this.eventQueue.clearEventsForUnit(event.target);\r\n            this.simResult.addDeath(event.target);\r\n        }\r\n\r\n        this.checkEncounterEnd();\r\n    }\r\n\r\n    processRegenTickEvent(event) {\r\n        let hitpointRegen = Math.floor(event.source.combatStats.maxHitpoints * event.source.combatStats.HPRegen);\r\n        let hitpointsAdded = event.source.addHitpoints(hitpointRegen);\r\n        // console.log(\"Added hitpoints:\", hitpointsAdded);\r\n\r\n        let manapointRegen = Math.floor(event.source.combatStats.maxManapoints * event.source.combatStats.MPRegen);\r\n        let manapointsAdded = event.source.addManapoints(manapointRegen);\r\n        // console.log(\"Added manapoints:\", manapointsAdded);\r\n\r\n        let regenTickEvent = new RegenTickEvent(this.simulationTime + 10 * 1e9, event.source);\r\n        this.eventQueue.addEvent(regenTickEvent);\r\n    }\r\n\r\n    processCheckBuffExpirationEvent(event) {\r\n        event.source.removeExpiredBuffs(this.simulationTime);\r\n    }\r\n\r\n    checkTriggers() {\r\n        let triggeredSomething;\r\n\r\n        do {\r\n            triggeredSomething = false;\r\n\r\n            this.players\r\n                .filter((player) => player.combatStats.currentHitpoints > 0)\r\n                .forEach((player) => {\r\n                    if (this.checkTriggersForUnit(player, this.players, this.enemies)) {\r\n                        triggeredSomething = true;\r\n                    }\r\n                });\r\n\r\n            if (this.enemies) {\r\n                this.enemies\r\n                    .filter((enemy) => enemy.combatStats.currentHitpoints > 0)\r\n                    .forEach((enemy) => {\r\n                        if (this.checkTriggersForUnit(enemy, this.enemies, this.players)) {\r\n                            triggeredSomething = true;\r\n                        }\r\n                    });\r\n            }\r\n        } while (triggeredSomething);\r\n    }\r\n\r\n    checkTriggersForUnit(unit, friendlies, enemies) {\r\n        console.assert(unit.combatStats.currentHitpoints > 0, \"Checking triggers for a dead unit\");\r\n\r\n        let triggeredSomething = false;\r\n        let target = CombatUtilities.getTarget(enemies);\r\n\r\n        for (const food of unit.food) {\r\n            if (food && food.shouldTrigger(this.simulationTime, unit, target, friendlies, enemies)) {\r\n                this.useConsumable(unit, food);\r\n                triggeredSomething = true;\r\n            }\r\n        }\r\n\r\n        for (const drink of unit.drinks) {\r\n            if (drink && drink.shouldTrigger(this.simulationTime, unit, target, friendlies, enemies)) {\r\n                this.useConsumable(unit, drink);\r\n                triggeredSomething = true;\r\n            }\r\n        }\r\n\r\n        for (const ability of unit.abilities) {\r\n            if (ability && ability.shouldTrigger(this.simulationTime, unit, target, friendlies, enemies)) {\r\n                this.useAbility(unit, ability);\r\n                triggeredSomething = true;\r\n            }\r\n        }\r\n\r\n        return triggeredSomething;\r\n    }\r\n\r\n    useConsumable(source, consumable) {\r\n        // console.log(\"Consuming:\", consumable);\r\n\r\n        console.assert(source.combatStats.currentHitpoints > 0, \"Dead unit is trying to use a consumable\");\r\n\r\n        consumable.lastUsed = this.simulationTime;\r\n        let cooldownReadyEvent = new CooldownReadyEvent(this.simulationTime + consumable.cooldownDuration);\r\n        this.eventQueue.addEvent(cooldownReadyEvent);\r\n\r\n        if (consumable.recoveryDuration == 0) {\r\n            if (consumable.hitpointRestore > 0) {\r\n                let hitpointsAdded = source.addHitpoints(consumable.hitpointRestore);\r\n                // console.log(\"Added hitpoints:\", hitpointsAdded);\r\n            }\r\n\r\n            if (consumable.manapointRestore > 0) {\r\n                let manapointsAdded = source.addManapoints(consumable.manapointRestore);\r\n                // console.log(\"Added manapoints:\", manapointsAdded);\r\n            }\r\n        } else {\r\n            let consumableTickEvent = new ConsumableTickEvent(\r\n                this.simulationTime + 2 * 1e9,\r\n                source,\r\n                consumable,\r\n                consumable.recoveryDuration / (2 * 1e9),\r\n                1\r\n            );\r\n            this.eventQueue.addEvent(consumableTickEvent);\r\n        }\r\n\r\n        for (const buff of consumable.buffs) {\r\n            source.addBuff(buff, this.simulationTime);\r\n            // console.log(\"Added buff:\", buff);\r\n            let checkBuffExpirationEvent = new CheckBuffExpirationEvent(this.simulationTime + buff.duration, source);\r\n            this.eventQueue.addEvent(checkBuffExpirationEvent);\r\n        }\r\n    }\r\n\r\n    useAbility(source, ability) {\r\n        console.assert(source.combatStats.currentHitpoints > 0, \"Dead unit is trying to cast an ability\");\r\n\r\n        if (source.combatStats.currentManapoints < ability.manaCost) {\r\n            return;\r\n        }\r\n\r\n        // console.log(\"Casting:\", ability);\r\n\r\n        source.combatStats.currentManapoints -= ability.manaCost;\r\n\r\n        let sourceIntelligenceExperience = CombatUtilities.calculateIntelligenceExperience(ability.manaCost);\r\n        this.simResult.addExperienceGain(source, \"intelligence\", sourceIntelligenceExperience);\r\n\r\n        ability.lastUsed = this.simulationTime;\r\n        let cooldownReadyEvent = new CooldownReadyEvent(this.simulationTime + ability.cooldownDuration);\r\n        this.eventQueue.addEvent(cooldownReadyEvent);\r\n\r\n        for (const abilityEffect of ability.abilityEffects) {\r\n            switch (abilityEffect.effectType) {\r\n                case \"/ability_effect_types/buff\":\r\n                    source.addBuff(abilityEffect.buff, this.simulationTime);\r\n                    // console.log(\"Added buff:\", abilityEffect.buff);\r\n                    let checkBuffExpirationEvent = new CheckBuffExpirationEvent(\r\n                        this.simulationTime + abilityEffect.buff.duration,\r\n                        source\r\n                    );\r\n                    this.eventQueue.addEvent(checkBuffExpirationEvent);\r\n                    break;\r\n                case \"/ability_effect_types/damage\":\r\n                    let targets;\r\n                    switch (abilityEffect.targetType) {\r\n                        case \"enemy\":\r\n                            targets = source.isPlayer\r\n                                ? [CombatUtilities.getTarget(this.enemies)]\r\n                                : [CombatUtilities.getTarget(this.players)];\r\n                            break;\r\n                        case \"all enemies\":\r\n                            targets = source.isPlayer ? this.enemies : this.players;\r\n                            break;\r\n                    }\r\n\r\n                    for (const target of targets.filter((unit) => unit.combatStats.currentHitpoints > 0)) {\r\n                        let { damageDone, damagePrevented, maxDamage, didHit } = CombatUtilities.processAttack(\r\n                            source,\r\n                            target,\r\n                            abilityEffect\r\n                        );\r\n\r\n                        if (abilityEffect.bleedRatio > 0 && damageDone > 0) {\r\n                            let bleedTickEvent = new BleedTickEvent(\r\n                                this.simulationTime + 2 * 1e9,\r\n                                target,\r\n                                damageDone * abilityEffect.bleedRatio,\r\n                                abilityEffect.duration / (2 * 1e9),\r\n                                1\r\n                            );\r\n                            this.eventQueue.addEvent(bleedTickEvent);\r\n                        }\r\n\r\n                        // console.log(\"Ability hit\", target.hrid, \"for\", damageDone);\r\n\r\n                        this.simResult.addAttack(source, target, ability.hrid, didHit ? damageDone : \"miss\");\r\n\r\n                        let targetStaminaExperience = CombatUtilities.calculateStaminaExperience(\r\n                            damagePrevented,\r\n                            damageDone\r\n                        );\r\n                        let targetDefenseExperience = CombatUtilities.calculateDefenseExperience(damagePrevented);\r\n                        let sourceAttackExperience = CombatUtilities.calculateAttackExperience(damageDone);\r\n                        let sourcePowerExperience = CombatUtilities.calculatePowerExperience(maxDamage);\r\n\r\n                        this.simResult.addExperienceGain(target, \"stamina\", targetStaminaExperience);\r\n                        this.simResult.addExperienceGain(target, \"defense\", targetDefenseExperience);\r\n                        this.simResult.addExperienceGain(source, \"attack\", sourceAttackExperience);\r\n                        this.simResult.addExperienceGain(source, \"power\", sourcePowerExperience);\r\n\r\n                        if (target.combatStats.currentHitpoints == 0) {\r\n                            this.eventQueue.clearEventsForUnit(target);\r\n                            this.simResult.addDeath(target);\r\n                            // console.log(target.hrid, \"died\");\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n\r\n        this.checkEncounterEnd();\r\n    }\r\n}\r\n\r\nexport default CombatSimulator;\r\n","class CombatUnit {\r\n    isPlayer;\r\n\r\n    // Base levels which don't change after initialization\r\n    staminaLevel = 1;\r\n    intelligenceLevel = 1;\r\n    attackLevel = 1;\r\n    powerLevel = 1;\r\n    defenseLevel = 1;\r\n\r\n    abilities = [null, null, null, null];\r\n    food = [null, null, null];\r\n    drinks = [null, null, null];\r\n\r\n    // Calculated combat stats including temporary buffs\r\n    combatStats = {\r\n        combatStyleHrid: \"smash\",\r\n        attackInterval: 3000000000,\r\n        stabAccuracy: 0,\r\n        slashAccuracy: 0,\r\n        smashAccuracy: 0,\r\n        stabDamage: 0,\r\n        slashDamage: 0,\r\n        smashDamage: 0,\r\n        stabEvasion: 0,\r\n        slashEvasion: 0,\r\n        smashEvasion: 0,\r\n        armor: 0,\r\n        lifeSteal: 0,\r\n        HPRegen: 0.005,\r\n        MPRegen: 0.01,\r\n        dropRate: 0,\r\n        foodSlots: 1,\r\n        drinkSlots: 0,\r\n        staminaLevel: 1,\r\n        intelligenceLevel: 1,\r\n        attackLevel: 1,\r\n        powerLevel: 1,\r\n        defenseLevel: 1,\r\n        maxHitpoints: 110,\r\n        currentHitpoints: 110,\r\n        maxManapoints: 110,\r\n        currentManapoints: 110,\r\n        stabAccuracyRating: 11,\r\n        slashAccuracyRating: 11,\r\n        smashAccuracyRating: 11,\r\n        stabMaxDamage: 11,\r\n        slashMaxDamage: 11,\r\n        smashMaxDamage: 11,\r\n        stabEvasionRating: 11,\r\n        slashEvasionRating: 11,\r\n        smashEvasionRating: 11,\r\n    };\r\n    combatBuffs = {};\r\n\r\n    constructor() {}\r\n\r\n    updateCombatStats() {\r\n        [\"stamina\", \"intelligence\", \"attack\", \"power\", \"defense\"].forEach((stat) => {\r\n            this.combatStats[stat + \"Level\"] = this[stat + \"Level\"];\r\n            let boosts = this.getBuffBoosts(\"/buff_types/\" + stat + \"_level\");\r\n            boosts.forEach((buff) => {\r\n                this.combatStats[stat + \"Level\"] += Math.floor(this[stat + \"Level\"] * buff.ratioBoost);\r\n                this.combatStats[stat + \"Level\"] += buff.flatBoost;\r\n            });\r\n        });\r\n\r\n        this.combatStats.maxHitpoints = 10 * (10 + this.combatStats.staminaLevel);\r\n        this.combatStats.maxManapoints = 10 * (10 + this.combatStats.intelligenceLevel);\r\n\r\n        let accuracyBoosts = this.getBuffBoosts(\"/buff_types/accuracy\");\r\n        let accuracyRatioBoost = accuracyBoosts[0]?.ratioBoost ?? 0;\r\n        console.assert(accuracyBoosts.length <= 1, \"Multiple accuracy buffs active\");\r\n\r\n        let damageBoosts = this.getBuffBoosts(\"/buff_types/damage\");\r\n        let damageRatioBoost = damageBoosts[0]?.ratioBoost ?? 0;\r\n        console.assert(damageBoosts.length <= 1, \"Multiple damage buffs active\");\r\n\r\n        [\"stab\", \"slash\", \"smash\"].forEach((style) => {\r\n            this.combatStats[style + \"AccuracyRating\"] =\r\n                (10 + this.combatStats.attackLevel) *\r\n                (1 + this.combatStats[style + \"Accuracy\"]) *\r\n                (1 + accuracyRatioBoost);\r\n            this.combatStats[style + \"MaxDamage\"] =\r\n                (10 + this.combatStats.powerLevel) * (1 + this.combatStats[style + \"Damage\"]) * (1 + damageRatioBoost);\r\n            this.combatStats[style + \"EvasionRating\"] =\r\n                (10 + this.combatStats.defenseLevel) * (1 + this.combatStats[style + \"Evasion\"]);\r\n        });\r\n\r\n        // TODO: Test how frenzy and swiftness coffee stack\r\n        let attackIntervalBoosts = this.getBuffBoosts(\"/buff_types/attack_speed\");\r\n        let attackIntervalRatioBoost = attackIntervalBoosts\r\n            .map((boost) => boost.ratioBoost)\r\n            .reduce((prev, cur) => prev + cur, 0);\r\n        this.combatStats.attackInterval = this.combatStats.attackInterval * (1 / (1 + attackIntervalRatioBoost));\r\n\r\n        let armorBoosts = this.getBuffBoosts(\"/buff_types/armor\");\r\n        let armorFlatBoost = armorBoosts[0]?.flatBoost ?? 0;\r\n        this.combatStats.armor += armorFlatBoost;\r\n        console.assert(armorBoosts.length <= 1, \"Multiple armor buffs active\");\r\n\r\n        let lifeStealBoosts = this.getBuffBoosts(\"/buff_types/life_steal\");\r\n        let lifeStealFlatBoost = lifeStealBoosts[0]?.flatBoost ?? 0;\r\n        this.combatStats.lifeSteal += lifeStealFlatBoost;\r\n        console.assert(lifeStealBoosts.length <= 1, \"Multiple life steal buffs active\");\r\n\r\n        let HPRegenBoosts = this.getBuffBoosts(\"/buff_types/hp_regen\");\r\n        let HPRegenFlatBoost = HPRegenBoosts[0]?.flatBoost ?? 0;\r\n        this.combatStats.HPRegen += HPRegenFlatBoost;\r\n        console.assert(HPRegenBoosts.length <= 1, \"Multiple hp regen buffs active\");\r\n\r\n        let MPRegenBoosts = this.getBuffBoosts(\"/buff_types/mp_regen\");\r\n        let MPRegenFlatBoost = MPRegenBoosts[0]?.flatBoost ?? 0;\r\n        this.combatStats.MPRegen += MPRegenFlatBoost;\r\n        console.assert(MPRegenBoosts.length <= 1, \"Multiple mp regen buffs active\");\r\n\r\n        let dropRateBoosts = this.getBuffBoosts(\"/buff_types/combat_drop_rate\");\r\n        let dropRateRatioBoost = dropRateBoosts[0]?.ratioBoost ?? 0;\r\n        this.combatStats.dropRate += dropRateRatioBoost;\r\n        console.assert(dropRateBoosts.length <= 1, \"Multiple drop rate buffs active\");\r\n    }\r\n\r\n    addBuff(buff, currentTime) {\r\n        buff.startTime = currentTime;\r\n        this.combatBuffs[buff.sourceHrid] = buff;\r\n\r\n        this.updateCombatStats();\r\n    }\r\n\r\n    removeExpiredBuffs(currentTime) {\r\n        let expiredBuffs = Object.values(this.combatBuffs).filter(\r\n            (buff) => buff.startTime + buff.duration <= currentTime\r\n        );\r\n        expiredBuffs.forEach((buff) => {\r\n            delete this.combatBuffs[buff.sourceHrid];\r\n        });\r\n\r\n        this.updateCombatStats();\r\n    }\r\n\r\n    clearBuffs() {\r\n        this.combatBuffs = {};\r\n    }\r\n\r\n    getBuffBoosts(type) {\r\n        let boosts = [];\r\n        Object.values(this.combatBuffs)\r\n            .filter((buff) => buff.typeHrid == type)\r\n            .forEach((buff) => {\r\n                boosts.push({ ratioBoost: buff.ratioBoost, flatBoost: buff.flatBoost });\r\n            });\r\n\r\n        return boosts;\r\n    }\r\n\r\n    reset(currentTime = 0) {\r\n        this.clearBuffs();\r\n        this.updateCombatStats();\r\n        this.resetCooldowns(currentTime);\r\n\r\n        this.combatStats.currentHitpoints = this.combatStats.maxHitpoints;\r\n        this.combatStats.currentManapoints = this.combatStats.maxManapoints;\r\n    }\r\n\r\n    resetCooldowns(currentTime = 0) {\r\n        this.food.filter((food) => food != null).forEach((food) => food.lastUsed = Number.MIN_SAFE_INTEGER);\r\n        this.drinks.filter((drink) => drink != null).forEach((drink) => drink.lastUsed = Number.MIN_SAFE_INTEGER);\r\n\r\n        this.abilities.filter((ability) => ability != null).forEach((ability) => {\r\n            if (this.isPlayer) {\r\n                ability.lastUsed = currentTime;\r\n            } else {\r\n                ability.lastUsed = currentTime - Math.floor(Math.random() * ability.cooldownDuration);\r\n            }\r\n        })\r\n    }\r\n\r\n    addHitpoints(hitpoints) {\r\n        let hitpointsAdded = 0;\r\n\r\n        if (this.combatStats.currentHitpoints >= this.combatStats.maxHitpoints) {\r\n            return hitpointsAdded;\r\n        }\r\n\r\n        let newHitpoints = Math.min(this.combatStats.currentHitpoints + hitpoints, this.combatStats.maxHitpoints);\r\n        hitpointsAdded = newHitpoints - this.combatStats.currentHitpoints;\r\n        this.combatStats.currentHitpoints = newHitpoints;\r\n\r\n        return hitpointsAdded;\r\n    }\r\n\r\n    addManapoints(manapoints) {\r\n        let manapointsAdded = 0;\r\n\r\n        if (this.combatStats.currentManapoints >= this.combatStats.maxManapoints) {\r\n            return manapointsAdded;\r\n        }\r\n\r\n        let newManapoints = Math.min(this.combatStats.currentManapoints + manapoints, this.combatStats.maxManapoints);\r\n        manapointsAdded = newManapoints - this.combatStats.currentManapoints;\r\n        this.combatStats.currentManapoints = newManapoints;\r\n\r\n        return manapointsAdded;\r\n    }\r\n}\r\n\r\nexport default CombatUnit;\r\n","class CombatUtilities {\r\n    static getTarget(enemies) {\r\n        if (!enemies) {\r\n            return null;\r\n        }\r\n        let target = enemies.find((enemy) => enemy.combatStats.currentHitpoints > 0);\r\n\r\n        return target ?? null;\r\n    }\r\n\r\n    static randomInt(min, max) {\r\n        return Math.floor(min + Math.random() * (max - min + 1));\r\n    }\r\n\r\n    static calculateHitChance(source, target, combatStyle) {\r\n        let sourceAccuracy = source.combatStats[combatStyle + \"AccuracyRating\"];\r\n        let targetEvasion = target.combatStats[combatStyle + \"EvasionRating\"];\r\n\r\n        let hitChance = Math.pow(sourceAccuracy, 1.4) / (Math.pow(sourceAccuracy, 1.4) + Math.pow(targetEvasion, 1.4));\r\n\r\n        return hitChance;\r\n    }\r\n\r\n    static processAttack(source, target, abilityEffect) {\r\n        let combatStyle = abilityEffect ? abilityEffect.combatStyleHrid : source.combatStats.combatStyleHrid;\r\n        let minDamage = 1;\r\n        let maxDamage = source.combatStats[combatStyle + \"MaxDamage\"];\r\n\r\n        if (abilityEffect) {\r\n            minDamage += abilityEffect.damageFlat;\r\n            maxDamage *= abilityEffect.damageRatio;\r\n            maxDamage += abilityEffect.damageFlat;\r\n        }\r\n\r\n        let damageRoll = CombatUtilities.randomInt(minDamage, maxDamage);\r\n        let premitigatedDamage = Math.min(damageRoll, target.combatStats.currentHitpoints);\r\n\r\n        let damageDone = 0;\r\n        let hitChance = CombatUtilities.calculateHitChance(source, target, combatStyle);\r\n\r\n        let didHit = false;\r\n        if (Math.random() < hitChance) {\r\n            didHit = true;\r\n            let damageTakenRatio = 100 / (100 + target.combatStats.armor);\r\n            let mitigatedDamage = damageTakenRatio * premitigatedDamage;\r\n            damageDone = CombatUtilities.randomInt(mitigatedDamage, mitigatedDamage);\r\n            target.combatStats.currentHitpoints -= damageDone;\r\n        }\r\n\r\n        let damagePrevented = premitigatedDamage - damageDone;\r\n\r\n        return { damageDone, damagePrevented, maxDamage, didHit };\r\n    }\r\n\r\n    static calculateTickValue(totalValue, totalTicks, currentTick) {\r\n        let currentSum = Math.floor((currentTick * totalValue) / totalTicks);\r\n        let previousSum = Math.floor(((currentTick - 1) * totalValue) / totalTicks);\r\n\r\n        return currentSum - previousSum;\r\n    }\r\n\r\n    static calculateStaminaExperience(damagePrevented, damageTaken) {\r\n        return 0.05 * damagePrevented + 0.5 * damageTaken;\r\n    }\r\n\r\n    static calculateIntelligenceExperience(manaUsed) {\r\n        return 0.5 * manaUsed;\r\n    }\r\n\r\n    static calculateAttackExperience(damageDone) {\r\n        return 0.45 + 0.125 * damageDone;\r\n    }\r\n\r\n    static calculatePowerExperience(maxDamage) {\r\n        return 0.3 + 0.04 * maxDamage;\r\n    }\r\n\r\n    static calculateDefenseExperience(damagePrevented) {\r\n        return 0.4 + 0.15 * damagePrevented;\r\n    }\r\n}\r\n\r\nexport default CombatUtilities;\r\n","import Buff from \"./buff\";\r\nimport itemDetailMap from \"./data/itemDetailMap.json\";\r\nimport Trigger from \"./trigger\";\r\n\r\nclass Consumable {\r\n    constructor(hrid, triggers = null) {\r\n        this.hrid = hrid;\r\n\r\n        let gameConsumable = itemDetailMap[this.hrid];\r\n        console.assert(gameConsumable, \"No consumable found for hrid:\" + this.hrid);\r\n\r\n        this.cooldownDuration = gameConsumable.consumableDetail.cooldownDuration;\r\n        this.hitpointRestore = gameConsumable.consumableDetail.hitpointRestore;\r\n        this.manapointRestore = gameConsumable.consumableDetail.manapointRestore;\r\n        this.recoveryDuration = gameConsumable.consumableDetail.recoveryDuration;\r\n\r\n        this.buffs = [];\r\n        if (gameConsumable.consumableDetail.buffs) {\r\n            for (const consumableBuff of gameConsumable.consumableDetail.buffs) {\r\n                let buff = new Buff(consumableBuff);\r\n                this.buffs.push(buff);\r\n            }\r\n        }\r\n\r\n        if (triggers) {\r\n            this.triggers = triggers;\r\n        } else {\r\n            this.triggers = [];\r\n            for (const defaultTrigger of gameConsumable.consumableDetail.defaultCombatTriggers) {\r\n                let trigger = new Trigger(\r\n                    defaultTrigger.dependencyHrid,\r\n                    defaultTrigger.conditionHrid,\r\n                    defaultTrigger.comparatorHrid,\r\n                    defaultTrigger.value\r\n                );\r\n                this.triggers.push(trigger);\r\n            }\r\n        }\r\n\r\n        this.lastUsed = Number.MIN_SAFE_INTEGER;\r\n    }\r\n\r\n    shouldTrigger(currentTime, source, target, friendlies, enemies) {\r\n        if (this.lastUsed + this.cooldownDuration > currentTime) {\r\n            return false;\r\n        }\r\n\r\n        if (this.triggers.length == 0) {\r\n            return true;\r\n        }\r\n\r\n        let shouldTrigger = true;\r\n        for (const trigger of this.triggers) {\r\n            if (!trigger.isActive(source, target, friendlies, enemies)) {\r\n                shouldTrigger = false;\r\n            }\r\n        }\r\n\r\n        return shouldTrigger;\r\n    }\r\n}\r\n\r\nexport default Consumable;\r\n","import itemDetailMap from \"./data/itemDetailMap.json\";\r\nimport enhancementLevelTotalMultiplierTable from \"./data/enhancementLevelTotalMultiplierTable.json\";\r\n\r\nclass Equipment {\r\n    constructor(hrid, enhancementLevel) {\r\n        this.hrid = hrid;\r\n        this.enhancementLevel = enhancementLevel;\r\n    }\r\n\r\n    getCombatStat(combatStat) {\r\n        let gameItem = itemDetailMap[this.hrid];\r\n        console.assert(gameItem, \"No equipment found for hrid:\" + this.hrid);\r\n\r\n        let multiplier = enhancementLevelTotalMultiplierTable[this.enhancementLevel];\r\n\r\n        let stat =\r\n            gameItem.equipmentDetail.combatStats[combatStat] +\r\n            multiplier * gameItem.equipmentDetail.combatEnhancementBonuses[combatStat];\r\n\r\n        return stat;\r\n    }\r\n\r\n    getCombatStyle() {\r\n        let gameItem = itemDetailMap[this.hrid];\r\n        console.assert(gameItem, \"No equipment found for hrid:\" + this.hrid);\r\n\r\n        let gameCombatStyle = gameItem.equipmentDetail.combatStyleHrids[0];\r\n        let combatStyle = gameCombatStyle.slice(gameCombatStyle.lastIndexOf(\"/\") + 1);\r\n\r\n        return combatStyle;\r\n    }\r\n}\r\n\r\nexport default Equipment;\r\n","import CombatEvent from \"./combatEvent\";\r\n\r\nclass AutoAttackEvent extends CombatEvent {\r\n    static type = \"autoAttack\";\r\n\r\n    constructor(time, source) {\r\n        super(AutoAttackEvent.type, time);\r\n\r\n        this.source = source;\r\n    }\r\n}\r\n\r\nexport default AutoAttackEvent;\r\n","import CombatEvent from \"./combatEvent\";\r\n\r\nclass BleedTickEvent extends CombatEvent {\r\n    static type = \"bleedTick\";\r\n\r\n    constructor(time, target, damage, totalTicks, currentTick) {\r\n        super(BleedTickEvent.type, time);\r\n\r\n        this.target = target;\r\n        this.damage = damage;\r\n        this.totalTicks = totalTicks;\r\n        this.currentTick = currentTick;\r\n    }\r\n}\r\n\r\nexport default BleedTickEvent;\r\n","import CombatEvent from \"./combatEvent\";\r\n\r\nclass CheckBuffExpirationEvent extends CombatEvent {\r\n    static type = \"checkBuffExpiration\";\r\n\r\n    constructor(time, source) {\r\n        super(CheckBuffExpirationEvent.type, time);\r\n\r\n        this.source = source;\r\n    }\r\n}\r\n\r\nexport default CheckBuffExpirationEvent;\r\n","class CombatEvent {\r\n    constructor(type, time) {\r\n        this.type = type;\r\n        this.time = time;\r\n    }\r\n}\r\n\r\nexport default CombatEvent;\r\n","import CombatEvent from \"./combatEvent\";\r\n\r\nclass CombatStartEvent extends CombatEvent {\r\n    static type = \"combatStart\";\r\n\r\n    constructor(time) {\r\n        super(CombatStartEvent.type, time);\r\n    }\r\n}\r\n\r\nexport default CombatStartEvent;\r\n","import CombatEvent from \"./combatEvent\";\r\n\r\nclass ConsumableTickEvent extends CombatEvent {\r\n    static type = \"consumableTick\";\r\n\r\n    constructor(time, source, consumable, totalTicks, currentTick) {\r\n        super(ConsumableTickEvent.type, time);\r\n\r\n        this.source = source;\r\n        this.consumable = consumable;\r\n        this.totalTicks = totalTicks;\r\n        this.currentTick = currentTick;\r\n    }\r\n}\r\n\r\nexport default ConsumableTickEvent;\r\n","import CombatEvent from \"./combatEvent\";\r\n\r\nclass CooldownReadyEvent extends CombatEvent {\r\n    static type = \"cooldownReady\";\r\n\r\n    constructor(time) {\r\n        super(CooldownReadyEvent.type, time);\r\n    }\r\n}\r\n\r\nexport default CooldownReadyEvent;\r\n","import CombatEvent from \"./combatEvent\";\r\n\r\nclass EnemyRespawnEvent extends CombatEvent {\r\n    static type = \"enemyRespawn\";\r\n\r\n    constructor(time) {\r\n        super(EnemyRespawnEvent.type, time);\r\n    }\r\n}\r\n\r\nexport default EnemyRespawnEvent;\r\n","import Heap from \"heap-js\";\r\n\r\nclass EventQueue {\r\n    constructor() {\r\n        this.minHeap = new Heap((a, b) => a.time - b.time);\r\n    }\r\n\r\n    addEvent(event) {\r\n        this.minHeap.push(event);\r\n    }\r\n\r\n    getNextEvent() {\r\n        return this.minHeap.pop();\r\n    }\r\n\r\n    clear() {\r\n        this.minHeap = new Heap((a, b) => a.time - b.time);\r\n    }\r\n\r\n    clearEventsForUnit(unit) {\r\n        this.clearMatching((event) => event.source == unit || event.target == unit);\r\n    }\r\n\r\n    clearEventsOfType(type) {\r\n        this.clearMatching((event) => event.type == type);\r\n    }\r\n\r\n    clearMatching(fn) {\r\n        let heapEvents = this.minHeap.toArray();\r\n\r\n        for (const event of heapEvents) {\r\n            if (fn(event)) {\r\n                this.minHeap.remove(event);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default EventQueue;\r\n","import CombatEvent from \"./combatEvent\";\r\n\r\nclass PlayerRespawnEvent extends CombatEvent {\r\n    static type = \"playerRespawn\";\r\n\r\n    constructor(time) {\r\n        super(PlayerRespawnEvent.type, time);\r\n    }\r\n}\r\n\r\nexport default PlayerRespawnEvent;\r\n","import CombatEvent from \"./combatEvent\";\r\n\r\nclass RegenTickEvent extends CombatEvent {\r\n    static type = \"regenTick\";\r\n\r\n    constructor(time, source) {\r\n        super(RegenTickEvent.type, time);\r\n\r\n        this.source = source;\r\n    }\r\n}\r\n\r\nexport default RegenTickEvent;\r\n","import Ability from \"./ability\";\r\nimport CombatUnit from \"./combatUnit\";\r\nimport combatMonsterDetailMap from \"./data/combatMonsterDetailMap.json\";\r\n\r\nclass Monster extends CombatUnit {\r\n    constructor(hrid) {\r\n        super();\r\n\r\n        this.isPlayer = false;\r\n        this.hrid = hrid;\r\n    }\r\n\r\n    updateCombatStats() {\r\n        let gameMonster = combatMonsterDetailMap[this.hrid];\r\n        console.assert(gameMonster, \"No monster found for hrid:\" + this.hrid);\r\n\r\n        this.staminaLevel = gameMonster.combatDetails.staminaLevel;\r\n        this.intelligenceLevel = gameMonster.combatDetails.intelligenceLevel;\r\n        this.attackLevel = gameMonster.combatDetails.attackLevel;\r\n        this.powerLevel = gameMonster.combatDetails.powerLevel;\r\n        this.defenseLevel = gameMonster.combatDetails.defenseLevel;\r\n\r\n        let gameCombatStyle = gameMonster.combatDetails.combatStyleHrid;\r\n        this.combatStats.combatStyleHrid = gameCombatStyle.slice(gameCombatStyle.lastIndexOf(\"/\") + 1);\r\n\r\n        for (const [key, value] of Object.entries(gameMonster.combatDetails.combatStats)) {\r\n            this.combatStats[key] = value;\r\n        }\r\n\r\n        for (let i = 0; i < gameMonster.abilities.length; i++) {\r\n            this.abilities[i] = new Ability(gameMonster.abilities[i].abilityHrid, gameMonster.abilities[i].level);\r\n        }\r\n\r\n        super.updateCombatStats();\r\n    }\r\n}\r\n\r\nexport default Monster;\r\n","import CombatUnit from \"./combatUnit\";\r\n\r\nclass Player extends CombatUnit {\r\n    equipment = {\r\n        \"/equipment_types/head\": null,\r\n        \"/equipment_types/body\": null,\r\n        \"/equipment_types/legs\": null,\r\n        \"/equipment_types/feet\": null,\r\n        \"/equipment_types/hands\": null,\r\n        \"/equipment_types/main_hand\": null,\r\n        \"/equipment_types/two_hand\": null,\r\n        \"/equipment_types/off_hand\": null,\r\n        \"/equipment_types/pouch\": null,\r\n    };\r\n\r\n    constructor() {\r\n        super();\r\n\r\n        this.isPlayer = true;\r\n        this.hrid = \"player\";\r\n    }\r\n\r\n    updateCombatStats() {\r\n        if (this.equipment[\"/equipment_types/main_hand\"]) {\r\n            this.combatStats.combatStyleHrid = this.equipment[\"/equipment_types/main_hand\"].getCombatStyle();\r\n            this.combatStats.attackInterval =\r\n                this.equipment[\"/equipment_types/main_hand\"].getCombatStat(\"attackInterval\");\r\n        } else if (this.equipment[\"/equipment_types/two_hand\"]) {\r\n            this.combatStats.combatStyleHrid = this.equipment[\"/equipment_types/two_hand\"].getCombatStyle();\r\n            this.combatStats.attackInterval =\r\n                this.equipment[\"/equipment_types/two_hand\"].getCombatStat(\"attackInterval\");\r\n        } else {\r\n            this.combatStats.combatStyleHrid = \"smash\";\r\n            this.combatStats.attackInterval = 3000000000;\r\n        }\r\n\r\n        [\r\n            \"stabAccuracy\",\r\n            \"slashAccuracy\",\r\n            \"smashAccuracy\",\r\n            \"stabDamage\",\r\n            \"slashDamage\",\r\n            \"smashDamage\",\r\n            \"stabEvasion\",\r\n            \"slashEvasion\",\r\n            \"smashEvasion\",\r\n            \"armor\",\r\n            \"lifeSteal\",\r\n        ].forEach((stat) => {\r\n            this.combatStats[stat] = Object.values(this.equipment)\r\n                .filter((equipment) => equipment != null)\r\n                .map((equipment) => equipment.getCombatStat(stat))\r\n                .reduce((prev, cur) => prev + cur, 0);\r\n        });\r\n\r\n        if (this.equipment[\"/equipment_types/pouch\"]) {\r\n            this.combatStats.foodSlots = 1 + this.equipment[\"/equipment_types/pouch\"].getCombatStat(\"foodSlots\");\r\n            this.combatStats.drinkSlots = this.equipment[\"/equipment_types/pouch\"].getCombatStat(\"drinkSlots\");\r\n        } else {\r\n            this.combatStats.foodSlots = 1;\r\n            this.combatStats.drinkSlots = 0;\r\n        }\r\n\r\n        this.combatStats.HPRegen = 0.005;\r\n        this.combatStats.MPRegen = 0.01;\r\n        this.combatStats.dropRate = 0;\r\n\r\n        super.updateCombatStats();\r\n    }\r\n}\r\n\r\nexport default Player;\r\n","class SimResult {\r\n    constructor() {\r\n        this.deaths = {};\r\n        this.experienceGained = {};\r\n        this.encounters = 0;\r\n        this.attacks = {};\r\n    }\r\n\r\n    addDeath(unit) {\r\n        if (!this.deaths[unit.hrid]) {\r\n            this.deaths[unit.hrid] = 0;\r\n        }\r\n\r\n        this.deaths[unit.hrid] += 1;\r\n    }\r\n\r\n    addExperienceGain(unit, type, experience) {\r\n        if (!unit.isPlayer) {\r\n            return;\r\n        }\r\n\r\n        if (!this.experienceGained[unit.hrid]) {\r\n            this.experienceGained[unit.hrid] = {\r\n                stamina: 0,\r\n                intelligence: 0,\r\n                attack: 0,\r\n                power: 0,\r\n                defense: 0,\r\n            };\r\n        }\r\n\r\n        this.experienceGained[unit.hrid][type] += experience;\r\n    }\r\n\r\n    addEncounterEnd() {\r\n        this.encounters++;\r\n    }\r\n\r\n    addAttack(source, target, ability, hit) {\r\n        if (!this.attacks[source.hrid]) {\r\n            this.attacks[source.hrid] = {};\r\n        }\r\n        if (!this.attacks[source.hrid][target.hrid]) {\r\n            this.attacks[source.hrid][target.hrid] = {};\r\n        }\r\n        if (!this.attacks[source.hrid][target.hrid][ability]) {\r\n            this.attacks[source.hrid][target.hrid][ability] = {};\r\n        }\r\n\r\n        if (!this.attacks[source.hrid][target.hrid][ability][hit]) {\r\n            this.attacks[source.hrid][target.hrid][ability][hit] = 0;\r\n        }\r\n\r\n        this.attacks[source.hrid][target.hrid][ability][hit] += 1;\r\n    }\r\n}\r\n\r\nexport default SimResult;\r\n","import combatTriggerDependencyDetailMap from \"./data/combatTriggerDependencyDetailMap.json\";\r\n\r\nclass Trigger {\r\n    constructor(dependencyHrid, conditionHrid, comparatorHrid, value = 0) {\r\n        this.dependencyHrid = dependencyHrid;\r\n        this.conditionHrid = conditionHrid;\r\n        this.comparatorHrid = comparatorHrid;\r\n        this.value = value;\r\n    }\r\n\r\n    isActive(source, target, friendlies, enemies) {\r\n        if (combatTriggerDependencyDetailMap[this.dependencyHrid].isSingleTarget) {\r\n            return this.isActiveSingleTarget(source, target);\r\n        } else {\r\n            return this.isActiveMultiTarget(friendlies, enemies);\r\n        }\r\n    }\r\n\r\n    isActiveSingleTarget(source, target) {\r\n        let dependencyValue;\r\n        switch (this.dependencyHrid) {\r\n            case \"/combat_trigger_dependencies/self\":\r\n                dependencyValue = this.getDependencyValue(source);\r\n                break;\r\n            case \"/combat_trigger_dependencies/targeted_enemy\":\r\n                if (!target) {\r\n                    return false;\r\n                }\r\n                dependencyValue = this.getDependencyValue(target);\r\n                break;\r\n            default:\r\n                console.error(\"Unknown dependencyHrid:\", this.dependencyHrid);\r\n                break;\r\n        }\r\n\r\n        return this.compareValue(dependencyValue);\r\n    }\r\n\r\n    isActiveMultiTarget(friendlies, enemies) {\r\n        let dependency;\r\n        switch (this.dependencyHrid) {\r\n            case \"/combat_trigger_dependencies/all_allies\":\r\n                dependency = friendlies;\r\n                break;\r\n            case \"/combat_trigger_dependencies/all_enemies\":\r\n                if (!enemies) {\r\n                    return false;\r\n                }\r\n                dependency = enemies;\r\n                break;\r\n            default:\r\n                console.error(\"Unknown dependencyHrid:\", this.dependencyHrid);\r\n                break;\r\n        }\r\n\r\n        let dependencyValue;\r\n        switch (this.conditionHrid) {\r\n            case \"/combat_trigger_conditions/number_of_active_units\":\r\n                dependencyValue = dependency.filter((unit) => unit.combatStats.currentHitpoints > 0).length;\r\n                break;\r\n            default:\r\n                dependencyValue = dependency\r\n                    .map((unit) => this.getDependencyValue(unit))\r\n                    .reduce((prev, cur) => prev + cur, 0);\r\n                break;\r\n        }\r\n\r\n        return this.compareValue(dependencyValue);\r\n    }\r\n\r\n    getDependencyValue(source) {\r\n        switch (this.conditionHrid) {\r\n            case \"/combat_trigger_conditions/attack_coffee\":\r\n            case \"/combat_trigger_conditions/berserk\":\r\n            case \"/combat_trigger_conditions/defense_coffee\":\r\n            case \"/combat_trigger_conditions/frenzy\":\r\n            case \"/combat_trigger_conditions/intelligence_coffee\":\r\n            case \"/combat_trigger_conditions/lucky_coffee\":\r\n            case \"/combat_trigger_conditions/power_coffee\":\r\n            case \"/combat_trigger_conditions/precision\":\r\n            case \"/combat_trigger_conditions/stamina_coffee\":\r\n            case \"/combat_trigger_conditions/super_attack_coffee\":\r\n            case \"/combat_trigger_conditions/super_defense_coffee\":\r\n            case \"/combat_trigger_conditions/super_intelligence_coffee\":\r\n            case \"/combat_trigger_conditions/super_power_coffee\":\r\n            case \"/combat_trigger_conditions/super_stamina_coffee\":\r\n            case \"/combat_trigger_conditions/swiftness_coffee\":\r\n            case \"/combat_trigger_conditions/toughness\":\r\n            case \"/combat_trigger_conditions/vampirism\":\r\n                let buffHrid = \"/buff_sources\";\r\n                buffHrid += this.conditionHrid.slice(this.conditionHrid.lastIndexOf(\"/\"));\r\n                return source.combatBuffs[buffHrid];\r\n            case \"/combat_trigger_conditions/current_hp\":\r\n                return source.combatStats.currentHitpoints;\r\n            case \"/combat_trigger_conditions/current_mp\":\r\n                return source.combatStats.currentManapoints;\r\n            case \"/combat_trigger_conditions/missing_hp\":\r\n                return source.combatStats.maxHitpoints - source.combatStats.currentHitpoints;\r\n            case \"/combat_trigger_conditions/missing_mp\":\r\n                return source.combatStats.maxManapoints - source.combatStats.currentManapoints;\r\n            default:\r\n                console.error(\"Unknown conditionHrid:\", this.conditionHrid);\r\n                break;\r\n        }\r\n    }\r\n\r\n    compareValue(dependencyValue) {\r\n        switch (this.comparatorHrid) {\r\n            case \"/combat_trigger_comparators/greater_than_equal\":\r\n                return dependencyValue >= this.value;\r\n            case \"/combat_trigger_comparators/less_than_equal\":\r\n                return dependencyValue <= this.value;\r\n            case \"/combat_trigger_comparators/is_active\":\r\n                return !!dependencyValue;\r\n            case \"/combat_trigger_comparators/is_inactive\":\r\n                return !dependencyValue;\r\n            default:\r\n                console.error(\"Unknown comparatorHrid\");\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\nexport default Trigger;\r\n","import actionDetailMap from \"./data/actionDetailMap.json\";\r\nimport Monster from \"./monster\";\r\n\r\nclass Zone {\r\n    constructor(hrid) {\r\n        this.hrid = hrid;\r\n\r\n        let gameZone = actionDetailMap[this.hrid];\r\n        this.monsterSpawnRates = gameZone.monsterSpawnRates;\r\n\r\n        let totalProbability = this.monsterSpawnRates\r\n            .map((encounter) => encounter.rate * 100) // Avoid floating point inaccuracies\r\n            .reduce((prev, cur) => prev + cur, 0);\r\n        console.assert(\r\n            totalProbability / 100 == 1,\r\n            \"Encounter probabilities do not add up to 1. Zone: \" + this.hrid + \" Probability:\" + totalProbability\r\n        );\r\n    }\r\n\r\n    getRandomEncounter() {\r\n        let encounter = null;\r\n        let cumulativeProbability = 0;\r\n        let randomNumber = Math.random();\r\n\r\n        for (let i = 0; i < this.monsterSpawnRates.length; i++) {\r\n            cumulativeProbability += this.monsterSpawnRates[i].rate;\r\n            if (cumulativeProbability > randomNumber) {\r\n                encounter = this.monsterSpawnRates[i];\r\n                break;\r\n            }\r\n        }\r\n\r\n        // This could happen very rarely due to floating point inaccuracies\r\n        if (encounter == null) {\r\n            encounter = this.monsterSpawnRates[this.monsterSpawnRates.length - 1];\r\n        }\r\n\r\n        return encounter.combatMonsterHrids.map((hrid) => new Monster(hrid));\r\n    }\r\n}\r\n\r\nexport default Zone;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".bundle.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = document.baseURI || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"main\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// no jsonp function","import Equipment from \"./combatsimulator/equipment.js\";\r\nimport Monster from \"./combatsimulator/monster.js\";\r\nimport Player from \"./combatsimulator/player.js\";\r\nimport Buff from \"./combatsimulator/buff.js\";\r\nimport abilityDetailMap from \"./combatsimulator/data/abilityDetailMap.json\";\r\nimport itemDetailMap from \"./combatsimulator/data/itemDetailMap.json\";\r\nimport Trigger from \"./combatsimulator/trigger.js\";\r\nimport Ability from \"./combatsimulator/ability.js\";\r\nimport Consumable from \"./combatsimulator/consumable.js\";\r\nimport Zone from \"./combatsimulator/zone.js\";\r\nimport CombatSimulator from \"./combatsimulator/combatSimulator.js\";\r\n\r\nlet button = document.querySelector(\"#button1\");\r\nlet input = document.querySelector(\"#input1\");\r\n\r\nlet worker = new Worker(new URL(\"worker.js\", import.meta.url));\r\n\r\nbutton.onclick = function () {\r\n    worker.postMessage(input.value);\r\n};\r\n\r\nworker.onmessage = function (event) {\r\n    window.alert(event.data);\r\n};\r\n\r\nlet player = new Player();\r\nplayer.staminaLevel = 65;\r\nplayer.intelligenceLevel = 69;\r\nplayer.attackLevel = 71;\r\nplayer.powerLevel = 69;\r\nplayer.defenseLevel = 68;\r\nplayer.equipment[\"/equipment_types/helm\"] = new Equipment(\"/items/rainbow_helmet\", 2);\r\nplayer.equipment[\"/equipment_types/body\"] = new Equipment(\"/items/rainbow_plate_body\", 2);\r\nplayer.equipment[\"/equipment_types/legs\"] = new Equipment(\"/items/rainbow_plate_legs\", 2);\r\nplayer.equipment[\"/equipment_types/feet\"] = new Equipment(\"/items/rainbow_boots\", 2);\r\nplayer.equipment[\"/equipment_types/hands\"] = new Equipment(\"/items/rainbow_gauntlets\", 2);\r\nplayer.equipment[\"/equipment_types/main_hand\"] = new Equipment(\"/items/gobo_smasher\", 6);\r\n// player.equipment[\"/equipment_types/off_hand\"] = new Equipment(\"/items/rainbow_buckler\", 2);\r\nplayer.equipment[\"/equipment_types/pouch\"] = new Equipment(\"/items/large_pouch\", 0);\r\n\r\nplayer.updateCombatStats();\r\nconsole.log(\"Player:\", player);\r\n\r\nlet monster = new Monster(\"/combat_monsters/alligator\");\r\nmonster.updateCombatStats();\r\nconsole.log(\"Monster:\", monster);\r\n\r\nlet buff = new Buff(abilityDetailMap[\"/abilities/vampirism\"].abilityEffects[0].buff, 9);\r\n// let buff = new Buff(itemDetailMap[\"/items/super_power_coffee\"].consumableDetail.buffs[0]);\r\n\r\nconsole.log(\"Buff:\", buff);\r\n\r\nlet currentTime = 1000000000;\r\nlet stats = {};\r\n\r\nObject.entries(player.combatStats).forEach(([key, value]) => {\r\n    stats[key] = [value];\r\n});\r\n\r\nplayer.addBuff(buff, currentTime);\r\nObject.entries(player.combatStats).forEach(([key, value]) => {\r\n    stats[key].push(value);\r\n});\r\n\r\nplayer.removeExpiredBuffs(currentTime + buff.duration);\r\nObject.entries(player.combatStats).forEach(([key, value]) => {\r\n    stats[key].push(value);\r\n});\r\n\r\nconsole.table(stats);\r\n\r\nplayer.reset();\r\n// player.addBuff(buff, currentTime);\r\n\r\nlet monster2 = new Monster(\"/combat_monsters/swampy\");\r\nlet monster3 = new Monster(\"/combat_monsters/snake\");\r\nmonster.reset();\r\nmonster2.reset();\r\nmonster3.reset();\r\nmonster2.combatStats.currentHitpoints -= 100;\r\nmonster3.combatStats.currentHitpoints -= 100;\r\n\r\nlet trigger = new Trigger(\r\n    \"/combat_trigger_dependencies/self\",\r\n    \"/combat_trigger_conditions/missing_hp\",\r\n    \"/combat_trigger_comparators/greater_than_equal\",\r\n    200\r\n);\r\nconsole.log(trigger.isActive(player, monster, [player], [monster, monster2, monster3]));\r\n\r\nlet zone = new Zone(\"/actions/combat/gobo_planet\");\r\nconsole.log(zone);\r\n\r\nlet counts = {};\r\nlet iterations = 100000;\r\nfor (let i = 0; i < iterations; i++) {\r\n    let encounter = zone.getRandomEncounter();\r\n    let encounterString = encounter.map((monster) => monster.hrid).join(\" \");\r\n\r\n    if (!counts[encounterString]) {\r\n        counts[encounterString] = 0;\r\n    }\r\n\r\n    counts[encounterString] += 1;\r\n}\r\n\r\nfor (const [key, value] of Object.entries(counts)) {\r\n    console.log(key, value / iterations);\r\n}\r\n\r\nlet ability1 = new Ability(\"/abilities/sweep\", 12);\r\nlet ability2 = new Ability(\"/abilities/cleave\", 1);\r\nlet ability3 = new Ability(\"/abilities/berserk\", 13);\r\n\r\nlet trigger1 = new Trigger(\r\n    \"/combat_trigger_dependencies/self\",\r\n    \"/combat_trigger_conditions/missing_hp\",\r\n    \"/combat_trigger_comparators/greater_than_equal\",\r\n    400\r\n);\r\n\r\nlet consumable1 = new Consumable(\"/items/mooberry_cake\");\r\nlet consumable2 = new Consumable(\"/items/dragon_fruit_yogurt\");\r\nlet consumable3 = new Consumable(\"/items/strawberry_cake\");\r\nlet consumable4 = new Consumable(\"/items/power_coffee\");\r\nlet consumable5 = new Consumable(\"/items/lucky_coffee\");\r\n\r\nplayer.food[0] = consumable1;\r\nplayer.food[1] = consumable2;\r\nplayer.food[2] = consumable3;\r\nplayer.drinks[0] = consumable4;\r\nplayer.drinks[1] = consumable5;\r\nplayer.abilities[0] = ability1;\r\nplayer.abilities[1] = ability2;\r\nplayer.abilities[2] = ability3;\r\n\r\nlet simulator = new CombatSimulator(player, zone);\r\nlet simResult = simulator.simulate(100 * 60 * 60 * 1e9);\r\n\r\nconsole.log(simResult);\r\n\r\nconsole.log(\"Simulated hours:\", simResult.simulatedTime / (60 * 60 * 1e9));\r\n\r\nconsole.log(\"Encounters per hour:\", simResult.encounters / (simResult.simulatedTime / (60 * 60 * 1e9)));\r\n\r\nconsole.log(\"Deaths per hour:\");\r\nfor (const [key, value] of Object.entries(simResult.deaths)) {\r\n    console.log(key, value / (simResult.simulatedTime / (60 * 60 * 1e9)));\r\n}\r\n\r\nconsole.log(\"Experience per hour:\");\r\nfor (const [key, value] of Object.entries(simResult.experienceGained[\"player\"])) {\r\n    console.log(key, value / (simResult.simulatedTime / (60 * 60 * 1e9)));\r\n}\r\n\r\nfor (const [source, targets] of Object.entries(simResult.attacks)) {\r\n    console.log(\"Attack stats for\", source);\r\n    for (const [target, abilities] of Object.entries(targets)) {\r\n        console.log(\"   Against\", target);\r\n        for (const [ability, attacks] of Object.entries(abilities)) {\r\n            console.log(\"       \", ability);\r\n            let misses = attacks[\"miss\"];\r\n            let attempts = Object.values(attacks).reduce((prev, cur) => prev + cur);\r\n            console.log(\"           Casts:\", attempts);\r\n            console.log(\"           Hitchance:\", 1 - misses / attempts);\r\n            let totalDamage = Object.entries(attacks)\r\n                .filter(([key, value]) => key != \"miss\")\r\n                .map(([key, value]) => key * value)\r\n                .reduce((prev, cur) => prev + cur);\r\n            console.log(\"           Average hit:\", totalDamage / (attempts - misses));\r\n        }\r\n    }\r\n}\r\n"],"names":[],"sourceRoot":""}